"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[385],{81971:e=>{e.exports=JSON.parse('{"functions":[{"name":"Save","desc":":::caution\\nAutomatically called by the save cycle. If you want to manually save to progress GlobalUpdates faster, wrap in a UpdateAsync call and pass the newestData to the callback.\\n\\nAs of right now it is messy to manually save, but it is possible. I will be adding a better way to do this in the future.\\n\\n```\\nkeep._store:UpdateAsync(keep._key, function(newestData)\\n\\treturn keep:Save(newestData, false)\\nend)\\n\\n**RESETS AUTO SAVE TIMER ON THIS KEEP**\\n:::caution","params":[{"name":"newestData","desc":"","lua_type":"{KeepStruct} The newest data to save"},{"name":"release","desc":"","lua_type":"{boolean} Whether to release the keep after saving"}],"returns":[{"desc":"","lua_type":"{KeepStruct} The newest data to save"}],"function_type":"method","source":{"line":403,"path":"src/DataKeep/Keep.lua"}},{"name":"IsActive","desc":"Returns if the Keep is active in the session (not locked by another server)","params":[],"returns":[{"desc":"","lua_type":"{boolean}"}],"function_type":"method","source":{"line":502,"path":"src/DataKeep/Keep.lua"}},{"name":"Identify","desc":"Returns the string identifier for the Keep","params":[],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":515,"path":"src/DataKeep/Keep.lua"}},{"name":"Release","desc":":::warning\\nThis is called before internal release, but after session release, no edits can be made after this point\\n:::warning","params":[],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":535,"path":"src/DataKeep/Keep.lua"}},{"name":"Reconcile","desc":"Fills in any missing data in the Keep, using the data template","params":[],"returns":[{"desc":"","lua_type":"void"}],"function_type":"method","source":{"line":560,"path":"src/DataKeep/Keep.lua"}},{"name":"GetActiveGlobalUpdates","desc":"Returns an array of active global updates (not locked/processed)","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":591,"path":"src/DataKeep/Keep.lua"}},{"name":"GetLockedGlobalUpdates","desc":"Returns an array of locked global updates (processed)\\n\\n:::caution\\nLock updates can **not** be changed, only cleared after done being used.\\n:::caution","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":616,"path":"src/DataKeep/Keep.lua"}},{"name":"ClearLockedUpdate","desc":"Clears a locked global update after being used\\n\\n:::warning\\nPassing an **active** global update id will throw an error & reject the Promise. \\n:::warning","params":[{"name":"id","desc":"","lua_type":"{number}"}],"returns":[{"desc":"","lua_type":"Promise<void>"}],"function_type":"method","source":{"line":643,"path":"src/DataKeep/Keep.lua"}}],"properties":[{"name":"GlobalStateProcessor","desc":"Define how to process global updates, by default just locks the global update (this is only ran if the keep is online)\\n\\nThe function is revealed the lock and remove global update function\\n\\n:::caution\\nUpdates *must* be locked eventually in order for OnGlobalUpdate to get fired\\n:::caution\\n\\n:::warning\\nThe lock and remove function revealed here are **NOT** the same as the ones in the Keep class, they are only for this function.\\n:::warning","lua_type":"(updateData: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void","source":{"line":137,"path":"src/DataKeep/Keep.lua"}},{"name":"OnGlobalUpdate","desc":"Fired when a new global update is locked and ready to be processed\\n\\n:::caution\\nONLY locked globals are fired\\n:::caution","lua_type":"Signal<(updateData: {}, updateId: number)>","source":{"line":148,"path":"src/DataKeep/Keep.lua"}},{"name":"OnRelease","desc":"Fired when the keep is released (fires before internally released, but after session release)","lua_type":"Signal<()>","source":{"line":155,"path":"src/DataKeep/Keep.lua"}}],"types":[{"name":"ActiveSession","desc":"","lua_type":"{PlaceID: number, JobID: number}","source":{"line":39,"path":"src/DataKeep/Keep.lua"}},{"name":"MetaData","desc":"","lua_type":"{ActiveSession: ActiveSession | nil, ForceLoad: ActiveSession | nil, LastUpdate: number}","source":{"line":44,"path":"src/DataKeep/Keep.lua"}},{"name":"GlobalUpdates","desc":"","lua_type":"{ID: number, Updates: { [number]: GlobalUpdate }}","source":{"line":63,"path":"src/DataKeep/Keep.lua"}},{"name":"Keep","desc":"","lua_type":"{ Data: {}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {}, OnGlobalUpdate: Signal<GlobalUpdate & number>, GlobalStateProcessor: (update: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void, OnRelease: Signal}","source":{"line":201,"path":"src/DataKeep/Keep.lua"}}],"name":"Keep","desc":"Keep class holds the data for a specific key in a store, and methods to manipulate data","realm":["Server"],"source":{"line":11,"path":"src/DataKeep/Keep.lua"}}')}}]);